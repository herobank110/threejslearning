<body style="margin:0">
<div></div>
<script type="module">
import * as THREE from "three";
let {innerWidth: w,innerHeight: h} = window
let cam = new THREE.PerspectiveCamera(40,w/h,1,10000)
cam.position.z = 300
let scene = new THREE.Scene
let t=10000,n=0;
let sm = new THREE.ShaderMaterial({
 vertexShader:`
  attribute float size;
  varying vec3 vColor;
  varying float fSize;
  void main() {
   vColor = color;
   vec4 mvp = modelViewMatrix * vec4(position, 1.0);
   gl_PointSize = size * (300.0 / -mvp.z);
   fSize = gl_PointSize;
   gl_Position = projectionMatrix * mvp;
  }`,
 fragmentShader:`
  varying vec3 vColor;
  varying float fSize;
  void main() {
   float dist = 1. - distance(gl_PointCoord, vec2(0.5, 0.5));
   float a = pow(dist + 0.3, fSize/2.0);
   gl_FragColor = vec4(vColor, a);
  }`,
 blending:THREE.AdditiveBlending,depthTest:false,transparent:true,vertexColors:true })
let geo = new THREE.BufferGeometry
geo.setAttribute('position',new THREE.Float32BufferAttribute([10,10,10,20,10,10],3))
geo.setAttribute('color',new THREE.Float32BufferAttribute([0.5, 0.5, 0, 1,1,1],3))
geo.setAttribute('size',new THREE.Float32BufferAttribute([30, 10],1))
//geo.attributes.position.push(new THREE.Vector(20,20,20));
geo.attributes.position.needsUpdate=true;
//geo.attributes.color.push(new THREE.Vector(1,1,1));
geo.attributes.color.needsUpdate=true;
let ps = new THREE.Points(geo,sm)
scene.add(ps)
let rend = new THREE.WebGLRenderer
rend.setPixelRatio(window.devicePixelRatio)
rend.setSize(w,h)
document.querySelector("div").appendChild(rend.domElement)
function tick(){
 rend.render(scene,cam)
 requestAnimationFrame(tick)
}
tick()
</script>
